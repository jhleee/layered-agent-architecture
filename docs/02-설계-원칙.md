# 제2장 통합 아키텍처 설계 원칙

> [← 이전: 제1장 서론](./01-서론.md) | [목차](./index.md) | [다음: 제3장 전체 구조 →](./03-전체-구조.md)

---

## 2.1 설계 철학

### 핵심 명제: "작게 시작해서 크게 키울 수 있는 구조"

통합 아키텍처의 설계 철학은 단 하나의 문장으로 요약된다:

> **최소한의 파일로 동작하되, 구조적 변경 없이 프로덕션 수준으로 확장할 수 있어야 한다.**

이 철학은 세 가지 원칙적 명제로 구체화된다:

1. **실용적 접근의 직관성과 평면 구조를 뼈대로 삼는다** — 폴더가 곧 레이어이며, 1단계 네스팅만으로 전체 구조를 파악할 수 있어야 한다.
2. **엔터프라이즈 접근의 완비된 레이어와 확장 패턴을 필요한 곳에 이식한다** — Memory, Model Factory, Config, Interfaces 등 프로덕션 필수 레이어를 포함하되, 각각은 선택적으로 활성화할 수 있다.
3. **어떤 레이어도 비어있는 채로 존재할 수 있어야 한다** — 레이어의 존재가 의무가 아니라 가능성이다. 필요해지는 시점에 활성화한다.

### 안티패턴 회피

통합 아키텍처는 양쪽 극단의 안티패턴을 동시에 회피한다:

| 안티패턴 | 출처 | 회피 전략 |
|---|---|---|
| 미래를 위한 과잉 추상화 | 엔터프라이즈 접근 | 현재 필요한 것만 구현하되, 확장 지점은 열어둔다 |
| 확장 불가능한 밀결합 구조 | 실용적 접근 | 레이어 간 단방향 의존을 처음부터 준수한다 |
| 불필요한 래퍼 계층 | 엔터프라이즈 접근 | `layers/` 같은 메타 폴더를 제거한다 |
| 역할 모호한 통합 파일 | 실용적 접근 | 파일 하나에 하나의 역할만 부여한다 |

---

## 2.2 7대 설계 원칙

### 원칙 1: 평면 우선 구조 (Flat-First)

```
# 엔터프라이즈 접근 (안티패턴)        # 통합 아키텍처 (권장)
agent_system/                         agent_system/
└── layers/          ← 불필요한 래퍼    ├── core/
    ├── state/                         ├── memory/
    ├── memory/                        ├── prompts/
    ├── prompt/                        ├── tools/
    ├── model/                         ├── nodes/
    ├── tool/                          ├── graphs/
    ├── agent/                         ├── interfaces/
    ├── graph/                         └── config/
    └── interface/
```

**규칙:**
- `layers/`, `modules/`, `components/` 같은 메타 폴더를 두지 않는다
- **폴더 = 레이어**이다. 폴더 이름만으로 해당 레이어의 관심사를 즉시 파악할 수 있어야 한다
- 네스팅 깊이는 최대 1단계로 제한한다 (예: `tools/search.py`까지만 허용, `tools/implementations/search/` 금지)

**효과:** 프로젝트 루트에서 `ls` 한 번으로 전체 아키텍처를 파악할 수 있다.

---

### 원칙 2: 역할별 파일 분리 (Role per File)

하나의 파일은 하나의 명확한 역할만 담당한다. 특히 `nodes/` 디렉토리에서 이 원칙이 중요하다:

```
nodes/
├── reasoning.py    # "무엇을 할지 결정" — LLM 호출, 계획 수립
├── execution.py    # "실제로 수행" — 도구 실행, 결과 처리
└── routing.py      # "어디로 보낼지 결정" — 조건부 엣지 분기
```

**규칙:**
- 파일명만으로 해당 파일의 역할을 유추할 수 있어야 한다
- 하나의 파일에 여러 관심사가 섞이면 분리한다
- 단, 과도한 분리도 금지한다 — 파일 하나가 함수 1개만 담고 있다면 인접 파일에 병합을 고려한다

**효과:** 새 팀원이 "도구 실행 로직은 어디서 수정하나요?"라는 질문에 `nodes/execution.py`라고 즉시 답할 수 있다.

---

### 원칙 3: 선택적 레이어 (Optional Layer)

모든 레이어가 처음부터 필요한 것은 아니다. 각 레이어는 **최소 → 완비**로 점진 확장할 수 있어야 한다.

```
Phase 1 (최소 시작)          Phase 3 (프로덕션 완비)
─────────────────           ─────────────────────
core/       ✅ 필수          core/        ✅
prompts/    ✅ 필수          memory/      ✅ 추가됨
tools/      ✅ 필수          prompts/     ✅
nodes/      ✅ 필수          tools/       ✅
graphs/     ✅ 필수          nodes/       ✅
                             graphs/      ✅
memory/     ⬜ 나중에         interfaces/  ✅ 추가됨
interfaces/ ⬜ 나중에         config/      ✅ 추가됨
config/     ⬜ 나중에
```

**규칙:**
- 레이어가 없어도 시스템은 동작해야 한다 (해당 레이어의 기본값이 인라인으로 제공됨)
- 레이어를 추가할 때 기존 코드의 구조적 변경이 최소화되어야 한다
- 각 레이어는 자체 `__init__.py`에서 공개 API를 내보낸다

**효과:** Day 1에 8개 파일로 동작하는 에이전트를 완성하고, 필요에 따라 점진 확장한다.

---

### 원칙 4: 팩토리로 추상화 (Factory Pattern)

직접 인스턴스를 생성하는 대신, 팩토리 함수를 통해 객체를 획득한다.

```python
# 안티패턴: 직접 생성이 코드 전체에 산재
llm = ChatOpenAI(model="gpt-4o", api_key=os.environ["OPENAI_API_KEY"])

# 권장: 팩토리를 통한 중앙 관리
from core.models import reasoning_model
llm = reasoning_model()
```

**적용 대상:**
- `core/models.py` — LLM 인스턴스 팩토리
- `tools/__init__.py` — 도구 레지스트리
- `memory/checkpointer.py` — 체크포인터 팩토리

**효과:**
- 모델 교체 시 팩토리 함수 하나만 수정
- 테스트 시 팩토리를 모킹하여 LLM 호출 없이 테스트 가능
- API 키가 한 곳에서만 참조됨

---

### 원칙 5: 단방향 의존 (Unidirectional Dependency)

레이어 간 의존은 **상위 → 하위** 방향으로만 허용한다. 역방향 의존(순환 의존)은 금지한다.

```
main.py → interfaces/ → graphs/ → nodes/ → prompts/, tools/
                                         → core/  (최하위)
                         graphs/ → memory/, config/
```

**규칙:**
- `core/`는 외부 의존이 없다 (자기 완결)
- 하위 레이어가 상위 레이어를 import하면 안 된다
- 순환 의존이 발생하면 공통 부분을 `core/`로 추출하여 해소한다

**효과:** 의존 그래프가 DAG(방향 비순환 그래프)를 유지하여, 어느 레이어를 수정해도 영향 범위를 예측할 수 있다.

---

### 원칙 6: 설정 외부화 (Externalize Configuration)

하드코딩된 값을 설정 파일로 추출한다.

```python
# 안티패턴: 하드코딩
llm = ChatOpenAI(model="gpt-4o", api_key="sk-...")

# 권장: 설정 외부화
from config.settings import get_settings
settings = get_settings()
llm = ChatOpenAI(model=settings.model_name, api_key=settings.openai_api_key)
```

**외부화 대상:**
- API 키, 모델명, 온도 등 → `config/settings.py` (환경 변수)
- 에이전트 행동 정의 (시스템 프롬프트, 도구 목록 등) → `config/agents.yaml` (선언적 구성)

**효과:** 코드 변경 없이 환경(개발/스테이징/프로덕션)에 따라 동작을 전환할 수 있다.

---

### 원칙 7: 서브그래프 독립성 (Subgraph Independence)

각 서브그래프는 독립 파일에 정의되며, 단독으로 테스트 가능해야 한다.

```
graphs/
├── builder.py       # 그래프 조립 유틸리티
├── researcher.py    # 리서처 서브그래프 (독립 파일)
├── writer.py        # 라이터 서브그래프 (독립 파일)
└── main.py          # 메인 그래프 (서브그래프 조립)
```

**규칙:**
- 서브그래프 1개 = 파일 1개
- 각 서브그래프는 자체 State를 정의하거나 메인 State의 부분 집합을 사용한다
- 서브그래프끼리 직접 import하지 않는다 — 메인 그래프가 조립한다

**효과:**
- 서브그래프별 독립 테스트 가능
- 새 서브그래프 추가 시 기존 코드 수정 없이 파일 추가 + 메인 그래프 등록으로 완료

---

## 2.3 채택·폐기 기준 프레임워크

통합 아키텍처는 실용적 접근(A)과 엔터프라이즈 접근(B) 양쪽에서 선별적으로 패턴을 채택했다. 채택과 폐기의 기준을 명확히 한다.

### 채택·폐기 매트릭스

| 출처 | 채택한 것 | 폐기한 것 |
|---|---|---|
| **실용적 접근(A)** | flat 폴더 구조 | `manager.py` 네이밍 (→ `builder.py`로 변경) |
| | `nodes/` 역할별 분리 (reasoning/execution/routing) | |
| | 도구 1파일 = 1도구 원칙 | |
| | 서브그래프 개별 파일 | |
| **엔터프라이즈 접근(B)** | `memory/` 레이어 (체크포인터 + 저장소) | `layers/` 메타 래퍼 |
| | Model Factory 패턴 | `agent/` 레이어 (역할 모호) |
| | Tool Registry 패턴 | `strategies.py` (routing.py에 흡수) |
| | `interfaces/` 레이어 | `formatter.py` (stream.py에 흡수) |
| | `config/` 레이어 | |
| | Builder 패턴 | |

### 채택·폐기 의사결정 플로차트

어떤 컴포넌트를 채택할지 판단할 때 아래 기준을 순서대로 적용한다:

```
┌─────────────────────┐
│  해당 컴포넌트가       │
│  프로덕션에 필수인가?   │
└─────────┬───────────┘
          │
     Yes ─┤
          │  → 채택 (엔터프라이즈 접근에서 가져오되 경량화)
          │
     No ──┤
          ▼
┌─────────────────────┐
│  코드 탐색 경로를      │
│  1단계 줄여주는가?     │
└─────────┬───────────┘
          │
     Yes ─┤
          │  → 채택 (실용적 접근의 방식 적용)
          │
     No ──┤
          ▼
┌─────────────────────┐
│  다른 컴포넌트에       │
│  병합 가능한가?        │
└─────────┬───────────┘
          │
     Yes ─┤  → 폐기 (인접 파일에 병합)
          │
     No ──┤  → 별도 파일로 유지
```

### 판단 기준 정리

- **채택 기준:** `프로덕션 필수 여부 × 구조적 간결성 기여도`
  - 프로덕션에서 반드시 필요하면 채택한다 (memory, config 등)
  - 파일 탐색 경로를 줄여주면 채택한다 (역할별 파일 분리 등)

- **폐기 기준:** `역할 모호성 × 불필요한 중첩 발생 여부`
  - 역할이 다른 컴포넌트와 겹치면 폐기하고 병합한다 (agent/ → nodes/에 흡수)
  - 중첩만 추가하고 가치를 제공하지 않으면 폐기한다 (layers/ 래퍼)

---

> [← 이전: 제1장 서론](./01-서론.md) | [목차](./index.md) | [다음: 제3장 전체 구조 →](./03-전체-구조.md)
