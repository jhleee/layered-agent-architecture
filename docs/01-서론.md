# 제1장 서론

> [목차로 돌아가기](./index.md) | [다음: 제2장 설계 원칙 →](./02-설계-원칙.md)

---

## 1.1 배경 및 문제 정의

### LLM 기반 에이전트 시스템의 부상

대규모 언어 모델(LLM)의 급격한 발전으로, 단순한 질의응답을 넘어 **도구를 호출하고, 계획을 수립하며, 반복적으로 추론하는 자율 에이전트 시스템**에 대한 수요가 폭발적으로 증가하고 있다. 이러한 에이전트는 검색, 데이터 분석, 코드 생성, 멀티스텝 워크플로우 등 다양한 영역에서 활용되고 있다.

### LangGraph의 위치와 역할

**LangGraph**는 LangChain 생태계에서 제공하는 에이전트 오케스트레이션 프레임워크로, 상태 기반의 그래프 구조를 통해 에이전트의 실행 흐름을 정의한다. 주요 특징은 다음과 같다:

- **상태 그래프(StateGraph):** 노드와 엣지로 구성된 방향 그래프로 실행 흐름을 표현
- **체크포인팅:** 실행 중간 상태를 저장하고 복원할 수 있는 내장 메커니즘
- **서브그래프:** 독립적으로 컴파일 가능한 하위 그래프로 복잡한 워크플로우를 모듈화
- **스트리밍:** 토큰 단위 실시간 응답 전달 지원

### 에이전트 아키텍처 설계의 딜레마

LangGraph로 에이전트를 구축하려는 개발자는 설계 초기에 반복적인 딜레마에 직면한다:

```
┌─────────────────────────────────────────────────────────────────┐
│                     아키텍처 설계 딜레마                          │
├────────────────────────────┬────────────────────────────────────┤
│  극단 A: 실용적 접근         │  극단 B: 엔터프라이즈 접근          │
├────────────────────────────┼────────────────────────────────────┤
│  • 5개 폴더, ~10개 파일      │  • 8개 폴더, ~25개 파일            │
│  • 빠른 프로토타이핑          │  • 완전한 레이어링                 │
│  • 낮은 진입 장벽             │  • 높은 확장성                     │
│  • 확장 시 전면 재설계 필요    │  • 초기 셋업 비용이 로직 개발 초과  │
└────────────────────────────┴────────────────────────────────────┘
```

**실용적 접근(극단 A)** 은 빠르게 동작하는 프로토타입을 만들 수 있지만, 도구가 10개를 넘거나 프로덕션 배포가 필요해지면 구조적 한계에 부딪힌다. Memory, Model 추상화, 환경 설정 같은 프로덕션 필수 레이어가 부재하기 때문이다.

**엔터프라이즈 접근(극단 B)** 은 확장성과 유지보수성을 갖추고 있지만, 초기 셋업에 소요되는 시간이 실제 비즈니스 로직 개발 시간을 초과한다. 단순한 프로젝트에는 과잉 설계가 되며, 깊은 레이어링으로 인해 인지 부하가 크다.

### 프로토타입에서 프로덕션으로의 전환 문제

가장 큰 문제는 **전환의 불연속성**이다. 실용적으로 시작한 프로젝트가 성장하면 전면 재설계가 필요하고, 엔터프라이즈로 시작한 프로젝트는 초기 속도가 느려 비즈니스 타이밍을 놓칠 수 있다. 이 딜레마는 프레임워크 자체의 문제가 아니라 **아키텍처 설계 패턴의 부재**에서 기인한다.

---

## 1.2 백서의 목적과 범위

### 목적

본 백서는 위 두 극단적 아키텍처의 **장점만을 선별적으로 취합한 통합 아키텍처**를 제시한다.

- 실용적 접근의 **직관성과 평면 구조**를 뼈대로 삼는다
- 엔터프라이즈 접근의 **완비된 레이어와 확장 패턴**을 필요한 곳에 이식한다
- 어떤 레이어도 "비어있는 채로" 존재할 수 있어, **최소 구성에서 시작해 점진적으로 확장**할 수 있다

### 대상 프레임워크

- **LangGraph** (Python)
- LangChain 생태계의 도구 및 모델 인터페이스 활용

### 다루는 범위

- 단일 에이전트의 내부 아키텍처
- 멀티 에이전트 서브그래프 구조
- 각 레이어별 설계 원칙과 구현 패턴
- 레이어 간 의존성 관리

### 다루지 않는 범위

- 분산 시스템 아키텍처
- 멀티 서버 오케스트레이션
- LangGraph Cloud 배포 상세
- 특정 LLM 모델의 프롬프트 엔지니어링

---

## 1.3 대상 독자

본 백서는 다음과 같은 독자를 대상으로 한다:

| 독자 유형 | 기대 효과 |
|---|---|
| LangGraph로 에이전트를 구축하려는 **개발자** | 처음부터 확장 가능한 구조로 시작할 수 있는 레퍼런스 |
| 기존 에이전트 프로젝트의 구조 개선을 고민하는 **팀** | 현재 구조에서 통합 아키텍처로의 마이그레이션 가이드 |
| AI 에이전트 시스템 아키텍처를 학습하려는 **엔지니어** | 레이어별 설계 의도와 패턴의 체계적 이해 |

### 사전 지식

- Python 중급 이상
- LangChain/LangGraph 기본 개념 (StateGraph, Node, Edge)
- REST API 기초 (FastAPI 경험 권장)

---

## 1.4 용어 정의

본 백서에서 사용하는 주요 용어를 아래와 같이 정의한다.

| 용어 | 정의 |
|---|---|
| **노드(Node)** | 그래프 내 하나의 처리 단위. Python 함수 또는 Runnable 객체로 구현된다. |
| **엣지(Edge)** | 노드 간 연결 및 전이 규칙. 무조건 엣지와 조건부 엣지로 구분된다. |
| **State** | 그래프 실행 중 모든 노드가 공유하는 상태 객체. `TypedDict`로 정의한다. |
| **Reducer** | State 필드의 병합 전략을 정의하는 함수. 예: `add_messages`는 메시지를 누적한다. |
| **서브그래프(Subgraph)** | 독립적으로 컴파일 가능한 하위 그래프. 메인 그래프에 노드로 삽입된다. |
| **체크포인터(Checkpointer)** | 그래프 실행의 중간 상태를 저장하고 복원하는 영속 메커니즘. |
| **레지스트리(Registry)** | 컴포넌트를 이름으로 등록하고 조회하는 패턴. 도구, 모델 등에 적용한다. |
| **팩토리(Factory)** | 객체 생성 로직을 캡슐화하여 용도별 프리셋을 제공하는 패턴. |
| **레이어(Layer)** | 특정 관심사를 담당하는 디렉토리 단위. 본 아키텍처에서는 폴더 = 레이어이다. |

---

## 1.5 백서 구성 로드맵

본 백서는 **설계 원칙 → 전체 구조 → 레이어별 상세 설계** 순서로 구성되어 있다.

```
┌──────────┐   ┌──────────┐   ┌────────────────────────────────┐
│  원칙     │──▶│  구조     │──▶│  레이어별 상세                   │
│  제2장    │   │  제3장    │   │  제4장(Core) ~ 제11장(Config)   │
└──────────┘   └──────────┘   └────────────────────────────────┘
```

- **제2장**에서는 통합 아키텍처의 설계 철학과 7대 원칙을 정의한다
- **제3장**에서는 전체 디렉토리 구조, 레이어 간 의존성, 데이터 흐름을 조망한다
- **제4~11장**에서는 각 레이어를 파일 단위로 상세히 설명하며, 코드 예시와 설계 의도를 함께 제시한다

---

> [목차로 돌아가기](./index.md) | [다음: 제2장 설계 원칙 →](./02-설계-원칙.md)
